// Heavily influenced by Kitze's useArray
// https://github.com/kitze/react-hanger/blob/master/src/array/useArray.ts
import { useCallback, useState, useMemo } from 'react';

export type UseArrayActions<T> = {
    set: (value: T | T[]) => void;
    push: (value: T | T[]) => void;
    pop: () => void;
    shift: () => void;
    unshift: (value: T | T[]) => void;
    clear: () => void;
    move: (from: number, to: number) => void;
    removeById: (
        id: T extends { id: string } ? string : T extends { id: number } ? number : unknown
    ) => void;
    modifyById: (
        id: T extends { id: string } ? string : T extends { id: number } ? number : unknown,
        newValue: Partial<T>
    ) => void;
    removeIndex: (index: number) => void;
    getFirst: () => T;
    getLast: () => T;
};
export type UseArray<T = any> = [T[], UseArrayActions<T>];

const useArray = <T = any>(initialValues: T[]): UseArray<T> => {
    const [value, setValue] = useState(initialValues);

    const clear = useCallback(() => setValue(() => []), []);

    const set = useCallback((item) => setValue(() => [...item]), []);

    const push = useCallback((item) => {
        setValue((v) => [...v, ...(Array.isArray(item) ? item : [item])]);
    }, []);

    const pop = useCallback(() => setValue((v) => v.slice(0, -1)), []);

    const shift = useCallback(() => setValue((v) => v.slice(1)), []);

    const unshift = useCallback(
        (item) => setValue((v) => [...(Array.isArray(item) ? item : [item]), ...v]),
        []
    );

    const move = useCallback(
        (from: number, to: number) =>
            setValue((it) => {
                const copy = it.slice();
                copy.splice(to < 0 ? copy.length + to : to, 0, copy.splice(from, 1)[0]);

                return copy;
            }),
        []
    );

    const removeById = useCallback(
        // @ts-ignore not every array that you will pass down will have object with id field.
        (id) => setValue((arr) => arr.filter((v) => v && v.id !== id)),
        []
    );

    const removeIndex = useCallback(
        (index) =>
            setValue((v) => {
                const copy = v.slice();
                copy.splice(index, 1);

                return copy;
            }),
        []
    );

    const modifyById = useCallback(
        (id, newValue) =>
            // @ts-ignore not every array that you will pass down will have object with id field.
            setValue((arr) => arr.map((v) => (v.id === id ? { ...v, ...newValue } : v))),
        []
    );

    const getFirst = useCallback(() => value[0], [value]);
    const getLast = useCallback(() => value[value.length - 1], [value]);

    const actions = useMemo(
        () => ({
            clear,
            getFirst,
            getLast,
            modifyById,
            move,
            pop,
            push,
            removeById,
            removeIndex,
            set,
            shift,
            unshift
        }),
        [
            clear,
            move,
            pop,
            push,
            shift,
            unshift,
            removeById,
            removeIndex,
            modifyById,
            getFirst,
            getLast,
            set
        ]
    );

    return [value, actions];
};

export default useArray;
